#!/usr/bin/env nextflow
/*
By Avery Davis Bell
Preps for salmon quant and runs salmon quant for multiple samples
*/

/*
#### Set up input parameters & defaults ####
*/
// Inputs: input/output related & general
params.sampleinfo = "" // Path to tab-delimited file containing sample information. Column names (descriptions): SampleID (sample ID as in input filenames, to be used in output filenames); RefDescrip (description of reference genome(s) to use in output file names); Bwt2BasePath (base path - before .#.bt2 - for bowtie2 index files - can just put xxx if not running bowtie2); SalmonIndexDir (path to directory generated by salmon index - can just put xxx if not running salmon); PooledTranscriptLengths (path to file containing emase.pooled.transcripts.info-style transcript length information, e.g. <ref>_<strain>__transcriptlengths.txt for the strain combinations in this sample); fldMean (mean library fragment length per sample, passed to --fldMean in salmon quant), fldSD (standard deviation library fragment length per sample, passed to --fldSD in salmon quant)
params.outputdir = "" // Parent output directory. Will be created if doesn't exist.
params.fastqdir = "" // Directory containing all fastq.gz files to process. One or more per sample.
params.libtype = 'PE' // SE or PE - is libary single end or paired end? So processing can be done appropriately.


// Inputs: Tunable parameters for trimming
params.trimmodir = "trimmomatic-0.39" // Path to trimmomatic v0.39 directory containing jar file and adapters directory (which itself contains the fasta files provided in next option, e.g. TruSeq3-SE.fa).
params.trimmofa = "TruSeq3-PE-2.fa" // name of fasta file within trimmodir adapters/ directory matching those used in library preparation
params.trimmoseedmism = 1 // Input to trimmomatic ILLUMINACLIP. How many of 16 bp can mismatch and still be counted as match.
params.trimmoadapclipthresh = 12 // Input to trimmomatic ILLUMINACLIP. How accurate match between adapter sequence and read must be. Each correct base adds 0.6. They recommend 7-15 (12 bases needed for 7, 25 for 15).

// Inputs: parameters for salmon
params.slibtype = "ISR" // salmon --libtype option matching the library being aligned here

// Inputs: organizational
params.salmonenv = '/storage/home/hcoda1/2/abell65/.conda/envs/salmon' // path to conda environment where salmon is installed

// Housekeeping:  create output directories
// Alignment & related info
outdir = file(params.outputdir)
outdir.mkdirs()
outtrimdir = file(params.outputdir + "/triminfo")
outtrimdir.mkdirs()
outsalmdir = file(params.outputdir + "/salmonout")
outsalmdir.mkdirs()

/*
#### Channel management ####
*/
//  Channel with all needed sample info as tuple.
formatChannel = Channel.fromPath(params.sampleinfo)
  .splitCsv(header: true, sep: '\t', strip: true)
  .map{row->
    return [row.SampleID, row.RefDescrip, row.SalmonIndexDir, row.fldMean, row.fldSD]
  }
  .set{sampleInfo}
formatChannel = Channel.fromPath(params.sampleinfo)
  .splitCsv(header: true, sep: '\t', strip: true)
  .map{row->
    return [row.SampleID, row.RefDescrip, row.SalmonIndexDir, row.fldMean, row.fldSD]
  }
  .set{sampleInfoPE}

/*
#### Processes ####
*/

process mergeLaneFastqs{
  // Merge files across lanes so that there's one fastq per sample

  input:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag) from sampleInfo

  output:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag), path("mergedlanes.fastq") into mergedfastqs

  when:
  params.libtype == 'SE'

  """
  zcat ${params.fastqdir}/*${mysamp}*.fastq.gz > mergedlanes.fastq
  """
}

process trimmoIlluminaAdapters{
  // Use trimmomatic to trim Illumina adapters from merged fastqs

  // save trimmomatic output summaries
  publishDir outtrimdir, mode: 'copy', pattern: "*_trimmomatic.out"

  input:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag), path(mergedfastq) from mergedfastqs

  output:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag), path("trimmed.fastq") into trimmedfastqs
  path("${mysamp}_trimmomatic.out") into trimlogs

  when:
  params.libtype == 'SE'

  """
  java -Xmx4g -jar ${params.trimmodir}/trimmomatic-0.39.jar \
  SE -threads 4 \
  ${mergedfastq} trimmed.fastq \
  ILLUMINACLIP:${params.trimmodir}/adapters/${params.trimmofa}:${params.trimmoseedmism}:30:${params.trimmoadapclipthresh} \
  2>${mysamp}_trimmomatic.out
  """
}

process trimmoIlluminaAdaptersPE{
  // Use trimmomatic to trim Illumina adapters from merged fastqs **when they are PE**
    // **currently PE assumed to be named _1 and _2.fastq.gz

  // save trimmomatic output summaries
  publishDir outtrimdir, mode: 'copy', pattern: "*_trimmomatic.out"
  publishDir outtrimdir, mode: 'copy', pattern: "*unpaired.fastq.gz"

  input:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag) from sampleInfoPE

  output:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag), path("trimmed_forward_paired.fastq"), path("trimmed_rev_paired.fastq") into trimmedfastqsPE // for salmon
  tuple path("${mysamp}_trimmomatic.out"), path ("*unpaired.fastq.gz") into trimlogsPE

  when:
  params.libtype == 'PE'

  """
  java -Xmx4g -jar ${params.trimmodir}/trimmomatic-0.39.jar \
  PE -threads 4 \
  ${params.fastqdir}/${mysamp}_1.fastq.gz ${params.fastqdir}/${mysamp}_2.fastq.gz \
  trimmed_forward_paired.fastq trimmed_forward_unpaired.fastq \
  trimmed_rev_paired.fastq trimmed_rev_unpaired.fastq \
  ILLUMINACLIP:${params.trimmodir}/adapters/${params.trimmofa}:${params.trimmoseedmism}:30:${params.trimmoadapclipthresh}:2:True \
  2>${mysamp}_trimmomatic.out

  # gzip unpaired read files for publishing
  gzip *_unpaired.fastq
  """
}


process salmonquantSE{
  // quantify RNA-seq data with salmon

  conda params.salmonenv

  // Save quantification outputs
  publishDir outsalmdir, mode: 'copy', overwrite: true

  input:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag), path(fastq) from trimmedfastqs

  output:
  tuple val(mysamp), val(refdescrip), path("${mysamp}_salmon_${refdescrip}") into salmoutsSE

  when:
  params.libtype == 'SE'
  """
  salmon quant \
  -i ${salmidx} \
  -l ${params.slibtype} \
  -r ${fastq} \
  -o ${mysamp}_salmon_${refdescrip} \
  --dumpEq \
  --fldMean ${meanfrag} \
  --fldSD ${sdfrag} \
  --rangeFactorizationBins 4 \
  --seqBias \
  --gcBias \
  -p 4
  """
}

process salmonquantPE{
  // quantify RNA-seq data with salmon
  conda params.salmonenv

  // Save quantification outputs
  publishDir outsalmdir, mode: 'copy', overwrite: true

  input:
  tuple val(mysamp), val(refdescrip), val(salmidx), val(meanfrag), val(sdfrag), path(fastq1), path(fastq2) from trimmedfastqsPE

  output:
  tuple val(mysamp), val(refdescrip), path("${mysamp}_salmon_${refdescrip}") into salmoutsPE

  when:
  params.libtype == 'PE'
  """
  salmon quant \
  -i ${salmidx} \
  -l ${params.slibtype} \
  -1 ${fastq1} -2 ${fastq2} \
  -o ${mysamp}_salmon_${refdescrip} \
  --dumpEq \
  --fldMean ${meanfrag} \
  --fldSD ${sdfrag} \
  --rangeFactorizationBins 4 \
  --seqBias \
  --gcBias \
  -p 4
  """
}
